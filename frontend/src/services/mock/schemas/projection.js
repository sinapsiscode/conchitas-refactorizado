import { generateUUID } from '../../../utils/uuid.js'

export const ProjectionSchema = {
  id: {
    type: 'string',
    required: true,
    default: () => generateUUID()
  },
  userId: {
    type: 'string',
    required: true
  },
  name: {
    type: 'string',
    required: true
  },
  description: {
    type: 'string',
    required: false
  },
  type: {
    type: 'string',
    required: true,
    enum: ['investment', 'harvest', 'complete', 'risk_analysis']
  },
  // Base Parameters
  baseInvestment: {
    type: 'number',
    required: true,
    min: 0
  },
  projectionMonths: {
    type: 'number',
    required: true,
    min: 1,
    max: 60
  },
  // Market Variables
  marketVariables: {
    type: 'object',
    required: true,
    default: {
      pricePerUnit: 3.5,
      mortalityRate: 15,
      growthRate: 100,
      harvestCycles: 3,
      cycleMonths: 8
    }
  },
  // Cost Structure
  costStructure: {
    type: 'object',
    required: true,
    default: {
      seedCostPerUnit: 0.05,
      maintenanceCostMonthly: 500,
      harvestCostPerUnit: 0.15,
      fixedCostsMonthly: 300
    }
  },
  // Risk Factors
  riskFactors: {
    type: 'object',
    required: true,
    default: {
      climaticRisk: 10,
      marketRisk: 15,
      operationalRisk: 5,
      financialRisk: 5
    }
  },
  // Scenarios
  scenarios: {
    type: 'array',
    required: false,
    default: []
  },
  // Results
  projectionResults: {
    type: 'object',
    required: false,
    default: null
  },
  // Status
  status: {
    type: 'string',
    required: true,
    enum: ['draft', 'calculated', 'approved', 'archived'],
    default: 'draft'
  },
  // Audit
  createdAt: {
    type: 'string',
    required: true,
    default: () => new Date().toISOString()
  },
  updatedAt: {
    type: 'string',
    required: true,
    default: () => new Date().toISOString()
  },
  calculatedAt: {
    type: 'string',
    required: false
  }
}

export const ProjectionScenarioSchema = {
  id: {
    type: 'string',
    required: true,
    default: () => generateUUID()
  },
  name: {
    type: 'string',
    required: true
  },
  type: {
    type: 'string',
    required: true,
    enum: ['optimistic', 'realistic', 'pessimistic', 'custom']
  },
  adjustments: {
    type: 'object',
    required: true,
    default: {
      priceAdjustment: 0,
      mortalityAdjustment: 0,
      costAdjustment: 0,
      volumeAdjustment: 0
    }
  },
  probability: {
    type: 'number',
    required: true,
    min: 0,
    max: 100,
    default: 33.33
  },
  results: {
    type: 'object',
    required: false,
    default: null
  }
}

export const ProjectionParametersSchema = {
  // Market parameters based on real data
  marketDefaults: {
    piuraSechura: {
      avgPricePerUnit: 3.5,
      minPrice: 2.0,
      maxPrice: 5.5,
      avgMortalityRate: 15,
      minMortality: 8,
      maxMortality: 25,
      avgGrowthDays: 240,
      harvestSizeDistribution: {
        XS: 5,
        S: 15,
        M: 40,
        L: 30,
        XL: 10
      }
    }
  },
  // Cost structure based on industry standards
  costDefaults: {
    seedCostRange: { min: 0.03, max: 0.08 },
    maintenanceRange: { min: 300, max: 800 },
    harvestCostRange: { min: 0.10, max: 0.25 },
    fixedCostsRange: { min: 200, max: 500 }
  },
  // Risk parameters
  riskDefaults: {
    lowRisk: { climate: 5, market: 10, operational: 3, financial: 3 },
    mediumRisk: { climate: 10, market: 15, operational: 5, financial: 5 },
    highRisk: { climate: 20, market: 25, operational: 10, financial: 10 }
  }
}

export const validateProjection = (data) => {
  const errors = []
  
  const autoGeneratedFields = ['id', 'createdAt', 'updatedAt']
  
  for (const [field, rules] of Object.entries(ProjectionSchema)) {
    if (autoGeneratedFields.includes(field)) {
      continue
    }
    
    const value = data[field]
    
    if (rules.required && (value === undefined || value === null || value === '')) {
      errors.push(`${field} es requerido`)
    }
    
    if (typeof value === 'number' && rules.min !== undefined && value < rules.min) {
      errors.push(`${field} debe ser mayor o igual a ${rules.min}`)
    }
    
    if (typeof value === 'number' && rules.max !== undefined && value > rules.max) {
      errors.push(`${field} debe ser menor o igual a ${rules.max}`)
    }
    
    if (value && rules.enum && !rules.enum.includes(value)) {
      errors.push(`${field} debe ser uno de: ${rules.enum.join(', ')}`)
    }
  }
  
  return errors
}