import { generateUUID } from '../../../utils/uuid.js'

export const InventorySchema = {
  id: {
    type: 'string',
    required: true,
    default: () => generateUUID()
  },
  category: {
    type: 'string',
    required: true
  },
  name: {
    type: 'string',
    required: true
  },
  description: {
    type: 'string',
    required: false
  },
  type: {
    type: 'string',
    required: false
  },
  origin: {
    type: 'string',
    required: false,
    enum: ['national', 'imported']
  },
  quantity: {
    type: 'number',
    required: true,
    min: 0
  },
  unit: {
    type: 'string',
    required: true,
    enum: ['units', 'meters', 'kg', 'sets', 'pieces', 'boxes', 'rolls']
  },
  unitCost: {
    type: 'number',
    required: true,
    min: 0
  },
  totalValue: {
    type: 'number',
    required: true,
    min: 0
  },
  minStock: {
    type: 'number',
    required: false,
    min: 0
  },
  location: {
    type: 'string',
    required: false
  },
  supplier: {
    type: 'string',
    required: false
  },
  lastPurchaseDate: {
    type: 'string',
    required: false
  },
  status: {
    type: 'string',
    required: true,
    enum: ['available', 'in_use', 'maintenance', 'damaged', 'depleted', 'disponible', 'asignado', 'mantenimiento', 'mixed'],
    default: 'available'
  },
  assignedTo: {
    type: 'string',
    required: false
  },
  assignmentDate: {
    type: 'string',
    required: false
  },
  assignmentNotes: {
    type: 'string',
    required: false
  },
  quantityBreakdown: {
    type: 'object',
    required: false
  },
  createdAt: {
    type: 'string',
    required: true,
    default: () => new Date().toISOString()
  },
  updatedAt: {
    type: 'string',
    required: true,
    default: () => new Date().toISOString()
  }
}

export const CategorySchema = {
  id: {
    type: 'string',
    required: true,
    default: () => generateUUID()
  },
  name: {
    type: 'string',
    required: true
  },
  description: {
    type: 'string',
    required: false
  },
  color: {
    type: 'string',
    required: false,
    default: '#6B7280'
  },
  icon: {
    type: 'string',
    required: false,
    default: 'üì¶'
  },
  isActive: {
    type: 'boolean',
    required: true,
    default: true
  },
  createdAt: {
    type: 'string',
    required: true,
    default: () => new Date().toISOString()
  }
}

// Categor√≠as predefinidas comunes en acuicultura
export const DEFAULT_CATEGORIES = [
  { id: 'cultivation', name: 'Sistemas de Cultivo', icon: 'üåä', color: '#0EA5E9' },
  { id: 'flotation', name: 'Flotaci√≥n', icon: 'üîµ', color: '#3B82F6' },
  { id: 'anchoring', name: 'Anclaje', icon: '‚öì', color: '#6B7280' },
  { id: 'harvest', name: 'Cosecha', icon: 'üé£', color: '#10B981' },
  { id: 'maintenance', name: 'Mantenimiento', icon: 'üîß', color: '#F59E0B' },
  { id: 'safety', name: 'Seguridad', icon: 'ü¶∫', color: '#EF4444' },
  { id: 'laboratory', name: 'Laboratorio', icon: 'üî¨', color: '#8B5CF6' },
  { id: 'packaging', name: 'Empaque', icon: 'üì¶', color: '#EC4899' }
]

export const InventoryMovementSchema = {
  id: {
    type: 'string',
    required: true,
    default: () => generateUUID()
  },
  inventoryId: {
    type: 'string',
    required: true
  },
  type: {
    type: 'string',
    required: true,
    enum: ['in', 'out', 'adjustment']
  },
  quantity: {
    type: 'number',
    required: true
  },
  previousQuantity: {
    type: 'number',
    required: true
  },
  newQuantity: {
    type: 'number',
    required: true
  },
  reason: {
    type: 'string',
    required: true
  },
  relatedId: {
    type: 'string',
    required: false
  },
  relatedType: {
    type: 'string',
    required: false,
    enum: ['sector', 'lot', 'harvest', 'maintenance']
  },
  date: {
    type: 'string',
    required: true,
    default: () => new Date().toISOString()
  },
  createdBy: {
    type: 'string',
    required: true
  }
}

export const validateInventory = (data) => {
  const errors = []
  
  // Campos que se generan autom√°ticamente en el servidor
  const autoGeneratedFields = ['id', 'createdAt', 'updatedAt']
  
  for (const [field, rules] of Object.entries(InventorySchema)) {
    // Saltar validaci√≥n de campos generados autom√°ticamente
    if (autoGeneratedFields.includes(field)) {
      continue
    }
    
    const value = data[field]
    
    if (rules.required && (value === undefined || value === null || value === '')) {
      errors.push(`${field} es requerido`)
    }
    
    if (typeof value === 'number' && rules.min !== undefined && value < rules.min) {
      errors.push(`${field} debe ser mayor o igual a ${rules.min}`)
    }
    
    if (value && rules.enum && !rules.enum.includes(value)) {
      errors.push(`${field} debe ser uno de: ${rules.enum.join(', ')}`)
    }
  }
  
  // Validar que totalValue sea correcto si se proporcionan quantity y unitCost
  if (data.quantity !== undefined && data.unitCost !== undefined && data.totalValue !== undefined) {
    const calculatedTotal = data.quantity * data.unitCost
    if (Math.abs(calculatedTotal - data.totalValue) > 0.01) {
      errors.push('El valor total debe ser igual a cantidad * costo unitario')
    }
  }
  
  return errors
}

export const validateCategory = (data) => {
  const errors = []
  
  if (!data.name || data.name.trim() === '') {
    errors.push('El nombre de la categor√≠a es requerido')
  }
  
  return errors
}

export const validateInventoryMovement = (data) => {
  const errors = []
  
  // Campos que se generan autom√°ticamente en el servidor
  const autoGeneratedFields = ['id', 'date']
  
  for (const [field, rules] of Object.entries(InventoryMovementSchema)) {
    // Saltar validaci√≥n de campos generados autom√°ticamente
    if (autoGeneratedFields.includes(field)) {
      continue
    }
    
    const value = data[field]
    
    if (rules.required && (value === undefined || value === null || value === '')) {
      errors.push(`${field} es requerido`)
    }
    
    if (value && rules.enum && !rules.enum.includes(value)) {
      errors.push(`${field} debe ser uno de: ${rules.enum.join(', ')}`)
    }
  }
  
  // Solo validar la cantidad si se proporcionan los campos necesarios
  if (data.type && data.type !== 'adjustment' && 
      data.previousQuantity !== undefined && 
      data.quantity !== undefined && 
      data.newQuantity !== undefined) {
    const expectedNewQuantity = data.type === 'in' 
      ? data.previousQuantity + data.quantity
      : data.previousQuantity - data.quantity
      
    if (Math.abs(expectedNewQuantity - data.newQuantity) > 0.01) {
      errors.push('La nueva cantidad no coincide con el movimiento')
    }
  }
  
  return errors
}