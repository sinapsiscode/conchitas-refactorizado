import { generateUUID } from '../../../utils/uuid.js'

export const IncomeStatementClosureSchema = {
  id: {
    type: 'string',
    required: true,
    default: () => generateUUID()
  },
  userId: {
    type: 'string',
    required: true
  },
  closureType: {
    type: 'string',
    required: true,
    enum: ['seeding', 'monthly', 'quarterly', 'annual', 'custom'],
    default: 'seeding'
  },
  periodStartDate: {
    type: 'string',
    required: true,
    validate: (value) => !isNaN(new Date(value).getTime())
  },
  periodEndDate: {
    type: 'string',
    required: true,
    validate: (value) => !isNaN(new Date(value).getTime())
  },
  // Financial Summary
  totalRevenues: {
    type: 'number',
    required: true,
    min: 0
  },
  totalExpenses: {
    type: 'number', 
    required: true,
    min: 0
  },
  grossProfit: {
    type: 'number',
    required: true
  },
  netProfit: {
    type: 'number',
    required: true
  },
  profitMargin: {
    type: 'number',
    required: true,
    min: -100,
    max: 100
  },
  // Detailed Breakdown
  revenueBreakdown: {
    type: 'object',
    required: true,
    properties: {
      harvestSales: { type: 'number', min: 0 },
      otherIncome: { type: 'number', min: 0 }
    }
  },
  expenseBreakdown: {
    type: 'object',
    required: true,
    properties: {
      operational: { type: 'number', min: 0 },
      harvesting: { type: 'number', min: 0 },
      equipment: { type: 'number', min: 0 },
      materials: { type: 'number', min: 0 },
      labor: { type: 'number', min: 0 },
      other: { type: 'number', min: 0 }
    }
  },
  // Volume Metrics
  totalQuantityHarvested: {
    type: 'number',
    required: true,
    min: 0
  },
  numberOfHarvests: {
    type: 'number',
    required: true,
    min: 0
  },
  averageRevenuePerHarvest: {
    type: 'number',
    required: true,
    min: 0
  },
  // Status and Metadata
  status: {
    type: 'string',
    required: true,
    enum: ['draft', 'finalized', 'registered_in_cash_flow'],
    default: 'draft'
  },
  notes: {
    type: 'string',
    required: false
  },
  // Seeding-specific information (when closureType is 'seeding')
  seedingInfo: {
    type: 'object',
    required: false,
    properties: {
      seedingId: { type: 'string' },
      sectorName: { type: 'string' },
      origin: { type: 'string' },
      initialQuantity: { type: 'number', min: 0 },
      currentQuantity: { type: 'number', min: 0 },
      entryDate: { type: 'string' },
      cultivationSystem: { type: 'string' }
    }
  },
  // Filters Applied (for transparency)
  appliedFilters: {
    type: 'object',
    required: false,
    properties: {
      sectorIds: { type: 'array' },
      lotIds: { type: 'array' },
      includeOnlyCompleted: { type: 'boolean' }
    }
  },
  // Related Data References
  includedHarvestIds: {
    type: 'array',
    required: true
  },
  includedExpenseIds: {
    type: 'array', 
    required: true
  },
  includedIncomeIds: {
    type: 'array',
    required: true
  },
  // Cash Flow Registration
  cashFlowEntryId: {
    type: 'string',
    required: false
  },
  registeredInCashFlowAt: {
    type: 'string',
    required: false,
    validate: (value) => !value || !isNaN(new Date(value).getTime())
  },
  // Audit Fields
  createdAt: {
    type: 'string',
    required: true,
    default: () => new Date().toISOString()
  },
  updatedAt: {
    type: 'string',
    required: true,
    default: () => new Date().toISOString()
  },
  finalizedAt: {
    type: 'string',
    required: false,
    validate: (value) => !value || !isNaN(new Date(value).getTime())
  },
  finalizedBy: {
    type: 'string',
    required: false
  }
}

export const validateIncomeStatementClosure = (data) => {
  const errors = []
  
  // Campos que se generan autom치ticamente en el servidor
  const autoGeneratedFields = ['id', 'createdAt', 'updatedAt']
  
  for (const [field, rules] of Object.entries(IncomeStatementClosureSchema)) {
    // Saltar validaci칩n de campos generados autom치ticamente
    if (autoGeneratedFields.includes(field)) {
      continue
    }
    
    const value = data[field]
    
    if (rules.required && (value === undefined || value === null || value === '')) {
      errors.push(`${field} es requerido`)
    }
    
    if (value !== undefined && value !== null && rules.validate && !rules.validate(value)) {
      errors.push(`${field} no tiene un formato v치lido`)
    }
    
    if (typeof value === 'number' && rules.min !== undefined && value < rules.min) {
      errors.push(`${field} debe ser mayor o igual a ${rules.min}`)
    }
    
    if (typeof value === 'number' && rules.max !== undefined && value > rules.max) {
      errors.push(`${field} debe ser menor o igual a ${rules.max}`)
    }
    
    if (value && rules.enum && !rules.enum.includes(value)) {
      errors.push(`${field} debe ser uno de: ${rules.enum.join(', ')}`)
    }
  }
  
  // Validaciones de negocio espec칤ficas
  if (data.periodStartDate && data.periodEndDate) {
    // Parse dates as strings to avoid timezone issues
    // When comparing YYYY-MM-DD dates, use string comparison
    const startDateStr = data.periodStartDate
    const endDateStr = data.periodEndDate

    console.log('游댌 [Validation] Date check in backend:', {
      periodStartDate: startDateStr,
      periodEndDate: endDateStr,
      stringComparison: startDateStr <= endDateStr,
      isStartGreater: startDateStr > endDateStr,
      closureType: data.closureType
    })

    // Para closureType 'custom' permitir fechas iguales
    if (data.closureType === 'custom') {
      // Solo error si startDate es estrictamente mayor que endDate
      // Usando comparaci칩n de strings para fechas en formato YYYY-MM-DD
      if (startDateStr > endDateStr) {
        errors.push('La fecha de inicio debe ser anterior o igual a la fecha de fin del per칤odo')
      }
    } else {
      // Para otros tipos, no permitir fechas iguales
      if (startDateStr >= endDateStr) {
        errors.push('La fecha de inicio debe ser anterior a la fecha de fin del per칤odo')
      }
    }
  }
  
  // Validar coherencia financiera
  if (data.totalRevenues !== undefined && data.totalExpenses !== undefined && data.grossProfit !== undefined) {
    const expectedGrossProfit = data.totalRevenues - data.totalExpenses
    if (Math.abs(data.grossProfit - expectedGrossProfit) > 0.01) {
      errors.push('El beneficio bruto debe ser igual a ingresos totales menos gastos totales')
    }
  }
  
  return errors
}

// Helper function to generate closure periods
export const generateClosurePeriods = (type, year = new Date().getFullYear()) => {
  const periods = []
  
  switch (type) {
    case 'monthly':
      for (let month = 0; month < 12; month++) {
        const start = new Date(year, month, 1)
        const end = new Date(year, month + 1, 0) // Last day of month
        periods.push({
          label: start.toLocaleDateString('es-PE', { year: 'numeric', month: 'long' }),
          startDate: start.toISOString().split('T')[0],
          endDate: end.toISOString().split('T')[0],
          type: 'monthly'
        })
      }
      break
      
    case 'quarterly':
      const quarters = [
        { start: [year, 0, 1], end: [year, 2, 31], label: `Q1 ${year}` },
        { start: [year, 3, 1], end: [year, 5, 30], label: `Q2 ${year}` },
        { start: [year, 6, 1], end: [year, 8, 30], label: `Q3 ${year}` },
        { start: [year, 9, 1], end: [year, 11, 31], label: `Q4 ${year}` }
      ]
      
      quarters.forEach(q => {
        const start = new Date(...q.start)
        const end = new Date(...q.end)
        periods.push({
          label: q.label,
          startDate: start.toISOString().split('T')[0],
          endDate: end.toISOString().split('T')[0],
          type: 'quarterly'
        })
      })
      break
      
    case 'annual':
      const start = new Date(year, 0, 1)
      const end = new Date(year, 11, 31)
      periods.push({
        label: `A침o ${year}`,
        startDate: start.toISOString().split('T')[0],
        endDate: end.toISOString().split('T')[0],
        type: 'annual'
      })
      break
  }
  
  return periods
}