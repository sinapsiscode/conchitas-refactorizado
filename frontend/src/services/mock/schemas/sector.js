import { generateUUID } from '../../../utils/uuid.js'

export const SectorSchema = {
  id: {
    type: 'string',
    required: true,
    default: () => generateUUID()
  },
  name: {
    type: 'string',
    required: true
  },
  userId: {
    type: 'string',
    required: true
  },
  location: {
    type: 'string',
    required: false
  },
  hectares: {
    type: 'number',
    required: false
  },
  status: {
    type: 'string',
    required: true,
    enum: ['active', 'inactive', 'maintenance'],
    default: 'active'
  },
  createdAt: {
    type: 'string',
    required: true,
    default: () => new Date().toISOString()
  },
  updatedAt: {
    type: 'string',
    required: true,
    default: () => new Date().toISOString()
  }
}

export const LotSchema = {
  id: {
    type: 'string',
    required: true,
    default: () => generateUUID()
  },
  sectorId: {
    type: 'string',
    required: true
  },
  lineId: {
    type: 'string',
    required: false
  },
  batteryId: {
    type: 'string',
    required: false
  },
  batteryLetter: {
    type: 'string',
    required: false,
    validate: (value) => !value || /^[A-Z]$/.test(value)
  },
  systems: {
    type: 'array',
    required: false,
    default: [],
    validate: (value) => {
      return Array.isArray(value) && 
             value.every(system => 
               typeof system.systemNumber === 'number' && 
               system.systemNumber >= 1 && 
               system.systemNumber <= 100 &&
               Array.isArray(system.floors) &&
               system.floors.every(floor => floor >= 1 && floor <= 10)
             )
    }
  },
  entryDate: {
    type: 'string',
    required: true,
    validate: (value) => !isNaN(new Date(value).getTime())
  },
  origin: {
    type: 'string',
    required: true
  },
  initialQuantity: {
    type: 'number',
    required: true,
    min: 0
  },
  currentQuantity: {
    type: 'number',
    required: false,
    min: 0
  },
  expectedMonthlyMortality: {
    type: 'number',
    required: true,
    min: 0,
    max: 100
  },
  cost: {
    type: 'number',
    required: true,
    min: 0
  },
  projectedHarvestDate: {
    type: 'string',
    required: false,
    validate: (value) => !value || !isNaN(new Date(value).getTime())
  },
  cultivationSystem: {
    type: 'string',
    required: true,
    enum: ['Cultivo suspendido', 'Cultivo de fondo'],
    default: 'Cultivo suspendido'
  },
  lineName: {
    type: 'string',
    required: false
  },
  lineNumber: {
    type: 'number',
    required: false,
    min: 1
  },
  theoreticalDensity: {
    type: 'number',
    required: false,
    min: 0
  },
  actualDensity: {
    type: 'number',
    required: false,
    min: 0
  },
  nextThiningDate: {
    type: 'string',
    required: false,
    validate: (value) => !value || !isNaN(new Date(value).getTime())
  },
  averageSize: {
    type: 'number',
    required: false,
    min: 0
  },
  maxSize: {
    type: 'number',
    required: false,
    min: 0
  },
  minSize: {
    type: 'number',
    required: false,
    min: 0
  },
  status: {
    type: 'string',
    required: true,
    enum: ['seeded', 'growing', 'ready', 'harvested'],
    default: 'seeded'
  },
  // Investment tracking
  hasInvestors: {
    type: 'boolean',
    required: false,
    default: false
  },
  investmentIds: {
    type: 'array',
    required: false,
    default: []
  },
  totalInvestment: {
    type: 'number',
    required: false,
    default: 0
  },
  ownershipDistribution: {
    type: 'object',
    required: false,
    default: {}
  },
  // Manejo de boyas utilizadas
  buoysUsed: {
    type: 'number',
    required: false,
    min: 0,
    default: 0
  },
  buoyInventoryIds: {
    type: 'array',
    required: false,
    default: []
  },
  createdAt: {
    type: 'string',
    required: true,
    default: () => new Date().toISOString()
  },
  updatedAt: {
    type: 'string',
    required: true,
    default: () => new Date().toISOString()
  }
}

export const validateSector = (data) => {
  const errors = []
  
  // Lista de campos que son generados automáticamente y no deben ser validados como requeridos
  const autoGeneratedFields = ['id', 'status', 'createdAt', 'updatedAt']
  
  for (const [field, rules] of Object.entries(SectorSchema)) {
    const value = data[field]
    
    // Solo validar campos requeridos que no son autogenerados
    if (rules.required && !autoGeneratedFields.includes(field) && (!value || value === '')) {
      errors.push(`${field} es requerido`)
    }
    
    if (value && rules.validate && !rules.validate(value)) {
      errors.push(`${field} no tiene un formato válido`)
    }
    
    if (value && rules.enum && !rules.enum.includes(value)) {
      errors.push(`${field} debe ser uno de: ${rules.enum.join(', ')}`)
    }
  }
  
  return errors
}

export const validateLot = (data) => {
  const errors = []
  
  // Create a copy of data with default values applied
  const dataWithDefaults = { ...data }
  
  for (const [field, rules] of Object.entries(LotSchema)) {
    // Apply default values if field is missing but has a default
    if ((dataWithDefaults[field] === undefined || dataWithDefaults[field] === null) && rules.default) {
      if (typeof rules.default === 'function') {
        dataWithDefaults[field] = rules.default()
      } else {
        dataWithDefaults[field] = rules.default
      }
    }
    
    const value = dataWithDefaults[field]
    
    // Only check required if no default was applied
    if (rules.required && (value === undefined || value === null || value === '')) {
      errors.push(`${field} es requerido`)
    }
    
    if (value !== undefined && value !== null && rules.validate && !rules.validate(value)) {
      errors.push(`${field} no tiene un formato válido`)
    }
    
    if (typeof value === 'number' && rules.min !== undefined && value < rules.min) {
      errors.push(`${field} debe ser mayor o igual a ${rules.min}`)
    }
    
    if (typeof value === 'number' && rules.max !== undefined && value > rules.max) {
      errors.push(`${field} debe ser menor o igual a ${rules.max}`)
    }
    
    if (value && rules.enum && !rules.enum.includes(value)) {
      errors.push(`${field} debe ser uno de: ${rules.enum.join(', ')}`)
    }
  }
  
  return errors
}