import { generateUUID } from '../../../utils/uuid.js'

export const CultivationLineSchema = {
  id: {
    type: 'string',
    required: true,
    default: () => generateUUID()
  },
  sectorId: {
    type: 'string',
    required: true
  },
  batteryId: {
    type: 'string',
    required: true
  },
  name: {
    type: 'string',
    required: true,
    minLength: 1,
    maxLength: 100,
    validate: (value) => /^[A-Z]-\d+$/.test(value) // Formato A-1, B-2, etc.
  },
  batteryLetter: {
    type: 'string',
    required: true,
    minLength: 1,
    maxLength: 1,
    validate: (value) => /^[A-Z]$/.test(value)
  },
  lineNumber: {
    type: 'number',
    required: true,
    min: 1
  },
  totalSystems: {
    type: 'number',
    required: true,
    default: 100
  },
  floorsPerSystem: {
    type: 'number',
    required: true,
    default: 10
  },
  occupiedSystems: {
    type: 'array',
    required: false,
    default: []
  },
  status: {
    type: 'string',
    required: true,
    enum: ['available', 'partial', 'full', 'maintenance'],
    default: 'available'
  },
  description: {
    type: 'string',
    required: false,
    maxLength: 500
  },
  createdAt: {
    type: 'string',
    required: true,
    default: () => new Date().toISOString()
  },
  updatedAt: {
    type: 'string',
    required: true,
    default: () => new Date().toISOString()
  }
}

export const SystemOccupationSchema = {
  systemNumber: {
    type: 'number',
    required: true,
    min: 1,
    max: 100
  },
  lotId: {
    type: 'string',
    required: true
  },
  occupiedFloors: {
    type: 'array',
    required: true,
    validate: (value) => {
      return Array.isArray(value) && 
             value.every(floor => typeof floor === 'number' && floor >= 1 && floor <= 10)
    }
  },
  seedingDate: {
    type: 'string',
    required: true,
    validate: (value) => !isNaN(new Date(value).getTime())
  }
}

export const validateCultivationLine = (data) => {
  const errors = []

  const autoGeneratedFields = ['id', 'createdAt', 'updatedAt', 'status']
  
  for (const [field, rules] of Object.entries(CultivationLineSchema)) {
    const value = data[field]
    
    if (rules.required && !autoGeneratedFields.includes(field) && (!value && value !== 0)) {
      errors.push(`${field} es requerido`)
    }
    
    if (value !== undefined && value !== null) {
      if (rules.type === 'string') {
        if (typeof value !== 'string') {
          errors.push(`${field} debe ser texto`)
        } else {
          if (rules.minLength && value.length < rules.minLength) {
            errors.push(`${field} debe tener al menos ${rules.minLength} caracteres`)
          }
          if (rules.maxLength && value.length > rules.maxLength) {
            errors.push(`${field} debe tener máximo ${rules.maxLength} caracteres`)
          }
        }
      }
      
      if (rules.type === 'number') {
        const numValue = parseFloat(value)
        if (isNaN(numValue)) {
          errors.push(`${field} debe ser un número válido`)
        } else {
          if (rules.min !== undefined && numValue < rules.min) {
            errors.push(`${field} debe ser mayor o igual a ${rules.min}`)
          }
          if (rules.max !== undefined && numValue > rules.max) {
            errors.push(`${field} debe ser menor o igual a ${rules.max}`)
          }
        }
      }
      
      if (rules.enum && !rules.enum.includes(value)) {
        errors.push(`${field} debe ser uno de: ${rules.enum.join(', ')}`)
      }
      
      if (rules.validate && !rules.validate(value)) {
        errors.push(`${field} no tiene un formato válido`)
      }
    }
  }
  
  return errors
}